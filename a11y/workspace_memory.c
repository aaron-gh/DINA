/**
 * @file workspace_memory.c
 * @brief Workspace memory implementation for DINA
 *
 * This module handles remembering workspace preferences for applications.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>

#include "../core/dina.h"
#include "workspace_memory.h"
#include "../util/util.h"

/* Static variables */
static AppPersist *app_persists = NULL;  /* Dynamic array of app persistence entries */
static int n_app_persists = 0;           /* Number of entries in app_persists */

/* Function declarations */
static void save_app_persist_file(void);
static void load_app_persist_file(void);

/**
 * @brief Initialize workspace memory
 * 
 * Set up workspace memory system
 */
void
workspace_memory_init(void)
{
    /* Load app persistence data from file */
    load_app_persist_file();
}

/**
 * @brief Clean up workspace memory
 * 
 * Release resources used by workspace memory
 */
void
workspace_memory_cleanup(void)
{
    /* Free app persist array */
    free(app_persists);
    app_persists = NULL;
    n_app_persists = 0;
}

/**
 * @brief Load application tag persistence data from file
 */
static void
load_app_persist_file(void)
{
    FILE *f;
    char path[512];
    char line[1024];
    char *home;
    int count = 0;
    
    /* Get path to config file */
    home = getenv("HOME");
    if (!home)
        return;  /* Can't get home directory */
    
    snprintf(path, sizeof(path), "%s/%s", home, APP_PERSIST_FILE);
    
    /* Try to open the file */
    f = fopen(path, "r");
    if (!f)
        return;  /* No file yet */
    
    /* First pass: count entries */
    while (fgets(line, sizeof(line), f)) {
        /* Skip comment lines and empty lines */
        if (line[0] == '#' || line[0] == '\n')
            continue;
            
        count++;
    }
    
    if (count > 0) {
        /* Allocate memory for entries */
        app_persists = ecalloc(count, sizeof(AppPersist));
        rewind(f);
        
        /* Now read in the entries */
        int i = 0;
        while (fgets(line, sizeof(line), f) && i < count) {
            /* Skip comment lines and empty lines */
            if (line[0] == '#' || line[0] == '\n')
                continue;
                
            /* Format: class|instance|tag */
            char *class_str = strtok(line, "|");
            char *instance_str = strtok(NULL, "|");
            char *tag_str = strtok(NULL, "\n");
            
            if (class_str && instance_str && tag_str) {
                strncpy(app_persists[i].class, class_str, sizeof(app_persists[i].class) - 1);
                strncpy(app_persists[i].instance, instance_str, sizeof(app_persists[i].instance) - 1);
                app_persists[i].tag = atoi(tag_str);
                i++;
            }
        }
        
        n_app_persists = i;
    }
    
    fclose(f);
}

/**
 * @brief Save application tag persistence data to file
 */
static void
save_app_persist_file(void)
{
    FILE *f;
    char path[512];
    char dir_path[512];
    char *home;
    int i;
    
    /* Get path to config file */
    home = getenv("HOME");
    if (!home)
        return;  /* Can't get home directory */
    
    snprintf(path, sizeof(path), "%s/%s", home, APP_PERSIST_FILE);
    
    /* Create directories if needed */
    snprintf(dir_path, sizeof(dir_path), "%s/.config", home);
    mkdir(dir_path, 0755);
    snprintf(dir_path, sizeof(dir_path), "%s/.config/dina", home);
    mkdir(dir_path, 0755);
    
    f = fopen(path, "w");
    if (!f)
        return;  /* Can't write file */
    
    /* Write header and format info */
    fprintf(f, "# DINA Workspace Layout Configuration\n");
    fprintf(f, "# Format: application_class|application_instance|workspace_number\n");
    fprintf(f, "# This file is automatically generated by DINA when you move windows between workspaces\n");
    fprintf(f, "# The window class and instance are from the X11 WM_CLASS property\n\n");
    
    /* Write each entry */
    for (i = 0; i < n_app_persists; i++) {
        /* Only write entries for tags 2-9 (don't persist tag 1) */
        if (app_persists[i].tag > 1) {
            fprintf(f, "%s|%s|%d\n", 
                app_persists[i].class, 
                app_persists[i].instance, 
                app_persists[i].tag);
        }
    }
    
    fclose(f);
}

/**
 * @brief Find an application in the persistence store
 * 
 * @param class Window class
 * @param instance Window instance
 * @return Index of the application or -1 if not found
 */
int
findapptagpersist(const char *class, const char *instance)
{
    int i;
    
    if (!app_persists || !class || !instance)
        return -1;
    
    for (i = 0; i < n_app_persists; i++) {
        if (strcmp(app_persists[i].class, class) == 0 &&
            strcmp(app_persists[i].instance, instance) == 0) {
            return i;
        }
    }
    
    return -1;  /* Not found */
}

/**
 * @brief Update an application's tag persistence
 * 
 * Store or remove a tag preference for an application
 * 
 * @param class Window class
 * @param instance Window instance
 * @param tag Tag number (1-9)
 */
void
updateapptagpersist(const char *class, const char *instance, int tag)
{
    int idx;
    
    /* Handle tag 1 differently - remove from persistence */
    if (tag <= 1) {
        if (!class || !instance)
            return;
            
        idx = findapptagpersist(class, instance);
        if (idx >= 0) {
            /* Remove entry by moving last entry to this position */
            if (idx < n_app_persists - 1) {
                /* Copy last entry to current position */
                strcpy(app_persists[idx].class, app_persists[n_app_persists-1].class);
                strcpy(app_persists[idx].instance, app_persists[n_app_persists-1].instance);
                app_persists[idx].tag = app_persists[n_app_persists-1].tag;
            }
            n_app_persists--;
        }
    } else {
        /* For tags 2-9, update or add entry */
        if (!class || !instance)
            return;
            
        idx = findapptagpersist(class, instance);
        if (idx >= 0) {
            /* Update existing entry */
            app_persists[idx].tag = tag;
        } else {
            /* Add new entry */
            AppPersist *new_persists = realloc(app_persists, (n_app_persists + 1) * sizeof(AppPersist));
            
            if (!new_persists)
                return;  /* Out of memory */
            
            app_persists = new_persists;
            strncpy(app_persists[n_app_persists].class, class, sizeof(app_persists[n_app_persists].class) - 1);
            strncpy(app_persists[n_app_persists].instance, instance, sizeof(app_persists[n_app_persists].instance) - 1);
            app_persists[n_app_persists].tag = tag;
            n_app_persists++;
        }
    }
    
    /* Save changes */
    save_app_persist_file();
}

/**
 * @brief Load the tag for a window
 * 
 * @param class Window class
 * @param instance Window instance
 * @return Tag number or -1 if not found
 */
int
load_window_tag(const char *class, const char *instance)
{
    int idx = findapptagpersist(class, instance);
    
    if (idx >= 0)
        return app_persists[idx].tag;
    else
        return -1;  /* Not found */
}

/**
 * @brief Apply workspace memory to a new window
 * 
 * @param c Client to check and apply workspace for
 * @param class Window class
 * @param instance Window instance
 * @return 1 if workspace was applied, 0 otherwise
 */
int
applypersistworkspace(Client *c, const char *class, const char *instance)
{
    int tag_num = load_window_tag(class, instance);
    
    if (tag_num > 0 && tag_num <= 9) {
        c->tags = 1 << (tag_num - 1);  /* Convert 1-based tag to bitmask */
        return 1;  /* Successfully applied */
    }
    
    return 0;  /* Not applied */
}

/**
 * @brief Check if a window should be remembered
 * 
 * @param class Window class
 * @param instance Window instance
 * @return 1 if should be remembered, 0 otherwise
 */
int
should_remember(const char *class, const char *instance)
{
    /* Remember all windows except those that start with DINA */
    return (class && strncmp(class, "DINA", 4) != 0);
}

/**
 * @brief Save the tag for a window
 * 
 * @param class Window class
 * @param instance Window instance
 * @param tag Tag number
 */
void
save_window_tag(const char *class, const char *instance, int tag)
{
    if (should_remember(class, instance)) {
        updateapptagpersist(class, instance, tag);
    }
}