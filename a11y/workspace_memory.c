/**
 * @file workspace_memory.c
 * @brief Workspace (tag) persistence implementation
 *
 * This module remembers which applications belong on which workspaces,
 * creating a consistent environment for blind users.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#include "workspace_memory.h"
#include "notify.h"
#include "../util/util.h"
#include "../core/dina.h"
#include "../wm/window.h"

/* Internal state */
static AppPersist *app_persists = NULL;  /* Dynamic array of app persistence entries */
static int n_app_persists = 0;           /* Number of entries in app_persists */

/**
 * @brief Load application tag persistence data
 * 
 * Read the workspace layout from disk
 */
void
loadapptagpersist(void)
{
    char *home = getenv("HOME");
    char path[512];
    FILE *f;
    
    if (!home)
        return;
    
    /* Free existing entries if any */
    if (app_persists) {
        free(app_persists);
        app_persists = NULL;
        n_app_persists = 0;
    }
    
    /* Construct path to persistence file in user's home directory */
    snprintf(path, sizeof(path), "%s/%s", home, APP_PERSIST_FILE);
    
    /* Ensure directory exists */
    char dir_path[512];
    snprintf(dir_path, sizeof(dir_path), "%s/.config", home);
    mkdir(dir_path, 0755);
    snprintf(dir_path, sizeof(dir_path), "%s/.config/dina", home);
    mkdir(dir_path, 0755);
    
    f = fopen(path, "r");
    if (!f)
        return;  /* File doesn't exist, that's fine */
    
    /* First, count the number of entries (non-comment lines) */
    char line[1024];
    int count = 0;
    
    while (fgets(line, sizeof(line), f)) {
        /* Skip comment lines and empty lines */
        if (line[0] != '#' && line[0] != '\n')
            count++;
    }
    
    /* Allocate memory for entries */
    if (count > 0) {
        app_persists = ecalloc(count, sizeof(AppPersist));
        rewind(f);
        
        /* Now read in the entries */
        int i = 0;
        while (fgets(line, sizeof(line), f) && i < count) {
            /* Skip comment lines and empty lines */
            if (line[0] == '#' || line[0] == '\n')
                continue;
                
            /* Format: class|instance|tag */
            char *class_str = strtok(line, "|");
            char *instance_str = strtok(NULL, "|");
            char *tag_str = strtok(NULL, "\n");
            
            if (class_str && instance_str && tag_str) {
                strncpy(app_persists[i].class, class_str, sizeof(app_persists[i].class) - 1);
                strncpy(app_persists[i].instance, instance_str, sizeof(app_persists[i].instance) - 1);
                app_persists[i].tag = atoi(tag_str);
                i++;
            }
        }
        n_app_persists = i;  /* In case we didn't read all lines successfully */
    }
    
    fclose(f);
}

/**
 * @brief Save application tag persistence data
 * 
 * Write the workspace layout to disk
 */
void
saveapptagpersist(void)
{
    char *home = getenv("HOME");
    char path[512];
    FILE *f;
    int i;
    
    if (!home || !app_persists || n_app_persists == 0)
        return;
    
    /* Construct path to persistence file in user's home directory */
    snprintf(path, sizeof(path), "%s/%s", home, APP_PERSIST_FILE);
    
    /* Ensure directory exists */
    char dir_path[512];
    snprintf(dir_path, sizeof(dir_path), "%s/.config", home);
    mkdir(dir_path, 0755);
    snprintf(dir_path, sizeof(dir_path), "%s/.config/dina", home);
    mkdir(dir_path, 0755);
    
    f = fopen(path, "w");
    if (!f)
        return;  /* Can't write file */
    
    /* Write header and format info */
    fprintf(f, "# DINA Workspace Layout Configuration\n");
    fprintf(f, "# Format: application_class|application_instance|workspace_number\n");
    fprintf(f, "# This file is automatically generated by DINA when you move windows between workspaces\n");
    fprintf(f, "# The window class and instance are from the X11 WM_CLASS property\n\n");
    
    /* Write each entry */
    for (i = 0; i < n_app_persists; i++) {
        /* Only write entries for tags 2-9 (don't persist tag 1) */
        if (app_persists[i].tag > 1) {
            fprintf(f, "%s|%s|%d\n", 
                app_persists[i].class, 
                app_persists[i].instance, 
                app_persists[i].tag);
        }
    }
    
    fclose(f);
}

/**
 * @brief Find an application in the persistence store
 * 
 * @param class Window class
 * @param instance Window instance
 * @return Index of the application or -1 if not found
 */
int
findapptagpersist(const char *class, const char *instance)
{
    int i;
    
    if (!app_persists || !class || !instance)
        return -1;
    
    for (i = 0; i < n_app_persists; i++) {
        if (strcmp(app_persists[i].class, class) == 0 &&
            strcmp(app_persists[i].instance, instance) == 0) {
            return i;
        }
    }
    
    return -1;  /* Not found */
}

/**
 * @brief Update an application's tag persistence
 * 
 * Store or remove a tag preference for an application
 * 
 * @param class Window class
 * @param instance Window instance
 * @param tag Tag number (1-9)
 */
void
updateapptagpersist(const char *class, const char *instance, int tag)
{
    int idx;
    
    /* Handle tag 1 differently - remove from persistence */
    if (tag <= 1) {
        if (!class || !instance)
            return;
            
        idx = findapptagpersist(class, instance);
        if (idx >= 0) {
            /* Remove entry by moving last entry to this position */
            if (idx < n_app_persists - 1) {
                /* Copy the last element to this position */
                strncpy(app_persists[idx].class, app_persists[n_app_persists - 1].class, 
                        sizeof(app_persists[idx].class) - 1);
                strncpy(app_persists[idx].instance, app_persists[n_app_persists - 1].instance, 
                        sizeof(app_persists[idx].instance) - 1);
                app_persists[idx].tag = app_persists[n_app_persists - 1].tag;
            }
            
            /* Reduce count */
            n_app_persists--;
            
            /* Save changes */
            saveapptagpersist();
        }
        return;
    }
    
    /* Normal case for tags 2-9 */
    if (!class || !instance)
        return;
    
    idx = findapptagpersist(class, instance);
    
    if (idx >= 0) {
        /* Update existing entry */
        app_persists[idx].tag = tag;
    } else {
        /* Add new entry */
        AppPersist *new_persists = realloc(app_persists, (n_app_persists + 1) * sizeof(AppPersist));
        
        if (!new_persists)
            return;  /* Out of memory */
        
        app_persists = new_persists;
        strncpy(app_persists[n_app_persists].class, class, sizeof(app_persists[n_app_persists].class) - 1);
        strncpy(app_persists[n_app_persists].instance, instance, sizeof(app_persists[n_app_persists].instance) - 1);
        app_persists[n_app_persists].tag = tag;
        n_app_persists++;
    }
    
    /* Save changes */
    saveapptagpersist();
}

/**
 * @brief Apply workspace memory to a new window
 * 
 * @param c Client to check and apply workspace for
 * @param class Window class
 * @param instance Window instance
 * @return 1 if workspace was applied, 0 otherwise
 */
int
applypersistworkspace(Client *c, const char *class, const char *instance)
{
    int persist_idx;
    
    if (!c || !class || !instance)
        return 0;
    
    /* Find persistent tag assignment */
    persist_idx = findapptagpersist(class, instance);
    if (persist_idx >= 0) {
        c->tags = 1 << (app_persists[persist_idx].tag - 1);
        
        /* Don't notify for tag 1 */
        if (app_persists[persist_idx].tag > 1) {
            notify_tag_placement(class, instance, app_persists[persist_idx].tag);
            return 1;
        }
    }
    
    return 0;
}

/**
 * @brief Initialize workspace memory subsystem
 */
void
workspace_memory_init(void)
{
    /* Load saved application tags */
    loadapptagpersist();
}

/**
 * @brief Clean up workspace memory resources
 */
void
workspace_memory_cleanup(void)
{
    /* Free memory */
    if (app_persists) {
        free(app_persists);
        app_persists = NULL;
        n_app_persists = 0;
    }
}