#!/bin/bash
#
# interactive-userinstall - Setup user preferences for DINA
#
# This script detects installed applications and allows the user to
# select their preferred browsers, file managers, and terminals.
# It then updates sxhkdrc configuration with the selected preferences.
# Fully accessible with keyboard navigation using dialog.

set -e

# Maximum accessibility options for dialog - absolute minimal display for screen readers
DIALOG_OPTS="--ascii-lines --no-shadow --no-mouse --stdout"

# Function to handle errors
error_exit() {
    echo "Error: $1" >&2
    
    # Minimal error dialog
    if command -v dialog >/dev/null 2>&1; then
        dialog $DIALOG_OPTS --title "Error" \
               --msgbox "Error: $1" 5 25
    fi
    
    exit 1
}

# Check if dialog is installed
if ! command -v dialog >/dev/null 2>&1; then
    error_exit "dialog is required but not installed. Please install it first."
fi

# Display welcome message
if ! dialog $DIALOG_OPTS --title "Setup" \
       --yesno "DINA Setup\n\nConfigure your applications?\n\nYes: Continue\nNo: Cancel" \
       7 40; then
    echo "Setup cancelled"
    exit 0
fi

# Detect installed browsers
BROWSERS=()
BROWSER_PATHS=()

check_browser() {
    if command -v "$1" >/dev/null 2>&1; then
        BROWSERS+=("$1")
        BROWSER_PATHS+=("$(command -v "$1")")
        return 0
    fi
    return 1
}

# Check for common browsers
check_browser "firefox" || true
check_browser "chromium" || true
check_browser "chromium-browser" || true
check_browser "google-chrome" || true
check_browser "brave" || true
check_browser "vivaldi" || true
check_browser "opera" || true
check_browser "qutebrowser" || true
check_browser "falkon" || true
check_browser "epiphany" || true
check_browser "midori" || true
check_browser "nyxt" || true

if [ ${#BROWSERS[@]} -eq 0 ]; then
    # Allow user to specify path manually
    BROWSER_PATH=$(dialog $DIALOG_OPTS --title "Browser" \
                         --inputbox "No browsers found. Enter path:" \
                         7 40)
    
    if [ $? -ne 0 ] || [ -z "$BROWSER_PATH" ]; then
        echo "No browser selected"
        BROWSER_CHOICE=""
    elif [ ! -x "$BROWSER_PATH" ]; then
        error_exit "The specified browser path is not executable."
    else
        BROWSER_CHOICE="$BROWSER_PATH"
        echo "Custom browser path set"
    fi
else
    # Create simple numbered options
    OPTIONS=()
    for i in "${!BROWSERS[@]}"; do
        OPTIONS+=("$i" "${BROWSERS[$i]}")
    done
    
    # Simple menu with minimal decoration
    BROWSER_INDEX=$(dialog $DIALOG_OPTS --title "Browser" \
                          --menu "Choose browser:" \
                          10 30 6 \
                          "${OPTIONS[@]}")
    
    # Check result
    if [ $? -eq 0 ] && [ -n "$BROWSER_INDEX" ]; then
        BROWSER_CHOICE="${BROWSER_PATHS[$BROWSER_INDEX]}"
        echo "${BROWSERS[$BROWSER_INDEX]} selected"
    else
        echo "No browser selected"
        BROWSER_CHOICE=""
    fi
fi

# Detect installed file managers
FILE_MANAGERS=()
FILE_MANAGER_PATHS=()

check_file_manager() {
    if command -v "$1" >/dev/null 2>&1; then
        FILE_MANAGERS+=("$1")
        FILE_MANAGER_PATHS+=("$(command -v "$1")")
        return 0
    fi
    return 1
}

# Check for common file managers
check_file_manager "nautilus" || true
check_file_manager "thunar" || true
check_file_manager "pcmanfm" || true
check_file_manager "dolphin" || true
check_file_manager "nemo" || true
check_file_manager "caja" || true
check_file_manager "spacefm" || true
check_file_manager "krusader" || true
check_file_manager "ranger" || true

if [ ${#FILE_MANAGERS[@]} -eq 0 ]; then
    # Allow user to specify path manually
    FILE_MANAGER_PATH=$(dialog $DIALOG_OPTS --title "File Manager" \
                              --inputbox "No file managers found. Enter path:" \
                              7 40)
    
    if [ $? -ne 0 ] || [ -z "$FILE_MANAGER_PATH" ]; then
        echo "No file manager selected"
        FILE_MANAGER_CHOICE=""
    elif [ ! -x "$FILE_MANAGER_PATH" ]; then
        error_exit "The specified file manager path is not executable."
    else
        FILE_MANAGER_CHOICE="$FILE_MANAGER_PATH"
        echo "Custom file manager path set"
    fi
else
    # Create simple options
    OPTIONS=()
    for i in "${!FILE_MANAGERS[@]}"; do
        OPTIONS+=("$i" "${FILE_MANAGERS[$i]}")
    done
    
    FILE_MANAGER_INDEX=$(dialog $DIALOG_OPTS --title "File Manager" \
                               --menu "Choose file manager:" \
                               10 30 6 \
                               "${OPTIONS[@]}")
                               
    # Check result
    if [ $? -eq 0 ] && [ -n "$FILE_MANAGER_INDEX" ]; then
        FILE_MANAGER_CHOICE="${FILE_MANAGER_PATHS[$FILE_MANAGER_INDEX]}"
        echo "${FILE_MANAGERS[$FILE_MANAGER_INDEX]} selected"
    else
        echo "No file manager selected"
        FILE_MANAGER_CHOICE=""
    fi
fi

# Detect installed terminals
TERMINALS=()
TERMINAL_PATHS=()

check_terminal() {
    if command -v "$1" >/dev/null 2>&1; then
        TERMINALS+=("$1")
        TERMINAL_PATHS+=("$(command -v "$1")")
        return 0
    fi
    return 1
}

# Check for common terminals
check_terminal "alacritty" || true
check_terminal "xterm" || true
check_terminal "urxvt" || true
check_terminal "kitty" || true
check_terminal "gnome-terminal" || true
check_terminal "konsole" || true
check_terminal "terminator" || true
check_terminal "xfce4-terminal" || true
check_terminal "tilix" || true
check_terminal "st" || true
check_terminal "foot" || true
check_terminal "wezterm" || true

if [ ${#TERMINALS[@]} -eq 0 ]; then
    # Allow user to specify path manually
    TERMINAL_PATH=$(dialog $DIALOG_OPTS --title "Terminal" \
                         --inputbox "No terminals found. Enter path:" \
                         7 40)
    
    if [ $? -ne 0 ] || [ -z "$TERMINAL_PATH" ]; then
        echo "No terminal selected"
        TERMINAL_CHOICE=""
    elif [ ! -x "$TERMINAL_PATH" ]; then
        error_exit "The specified terminal path is not executable."
    else
        TERMINAL_CHOICE="$TERMINAL_PATH"
        echo "Custom terminal path set"
    fi
else
    # Create simple options
    OPTIONS=()
    for i in "${!TERMINALS[@]}"; do
        OPTIONS+=("$i" "${TERMINALS[$i]}")
    done
    
    TERMINAL_INDEX=$(dialog $DIALOG_OPTS --title "Terminal" \
                           --menu "Choose terminal:" \
                           10 30 6 \
                           "${OPTIONS[@]}")
                           
    # Check result
    if [ $? -eq 0 ] && [ -n "$TERMINAL_INDEX" ]; then
        TERMINAL_CHOICE="${TERMINAL_PATHS[$TERMINAL_INDEX]}"
        echo "${TERMINALS[$TERMINAL_INDEX]} selected"
    else
        echo "No terminal selected"
        TERMINAL_CHOICE=""
    fi
fi

# Confirmation dialog with minimal text
BROWSER_NAME=$(basename "${BROWSER_CHOICE:-None}" 2>/dev/null || echo "None")
FILE_MANAGER_NAME=$(basename "${FILE_MANAGER_CHOICE:-None}" 2>/dev/null || echo "None")
TERMINAL_NAME=$(basename "${TERMINAL_CHOICE:-None}" 2>/dev/null || echo "None")

if ! dialog $DIALOG_OPTS --title "Confirm" \
         --yesno "Browser: ${BROWSER_NAME}\nFile Manager: ${FILE_MANAGER_NAME}\nTerminal: ${TERMINAL_NAME}\n\nConfirm?" \
         7 40; then
    echo "Setup cancelled"
    echo "Setup cancelled by user." >&2
    exit 0
fi

echo "Updating configuration..."

# Path to sxhkdrc
SXHKDRC="$HOME/.config/sxhkd/sxhkdrc"
# Also check in DINA directory
if [ ! -f "$SXHKDRC" ]; then
    # Get the script's directory
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    # Go up one directory (assuming script is in scripts/)
    DINA_DIR="$(dirname "$SCRIPT_DIR")"
    SXHKDRC="$DINA_DIR/sxhkd/sxhkdrc"
fi

# Create ~/.config/sxhkd directory if it doesn't exist
if [ ! -d "$HOME/.config/sxhkd" ]; then
    mkdir -p "$HOME/.config/sxhkd"
fi

# If sxhkdrc doesn't exist in user's config, copy it from DINA
if [ ! -f "$HOME/.config/sxhkd/sxhkdrc" ]; then
    # Get the script's directory if not already set
    if [ -z "$SCRIPT_DIR" ]; then
        SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        DINA_DIR="$(dirname "$SCRIPT_DIR")"
    fi
    
    if [ -f "$DINA_DIR/sxhkd/sxhkdrc" ]; then
        cp "$DINA_DIR/sxhkd/sxhkdrc" "$HOME/.config/sxhkd/sxhkdrc"
        SXHKDRC="$HOME/.config/sxhkd/sxhkdrc"
    else
        error_exit "Could not find sxhkdrc file."
    fi
fi

# Make a backup of the original file
cp "$SXHKDRC" "${SXHKDRC}.bak"

# Update sxhkdrc with the selected applications
if [ -n "$BROWSER_CHOICE" ]; then
    # Check if browser binding already exists
    if grep -q "^super + w" "$SXHKDRC"; then
        # Get the line number of the binding
        LINE_NUM=$(grep -n "^super + w" "$SXHKDRC" | cut -d: -f1)
        
        # Create a temporary file that replaces the binding
        {
            # Print file up to the binding line
            head -n $((LINE_NUM-1)) "$SXHKDRC"
            
            # Add the new binding
            echo "super + w"
            echo "	$BROWSER_CHOICE"
            
            # Print the rest of the file, skipping the old binding and command
            tail -n +$((LINE_NUM+2)) "$SXHKDRC"
        } > "${SXHKDRC}.tmp"
        
        # Replace the original file
        mv "${SXHKDRC}.tmp" "$SXHKDRC"
    else
        # Add new binding
        echo -e "\nsuper + w\n\t$BROWSER_CHOICE" >> "$SXHKDRC"
    fi
    echo "Browser shortcut set to Super+W"
fi

if [ -n "$FILE_MANAGER_CHOICE" ]; then
    # Check if file manager binding already exists
    if grep -q "^super + f" "$SXHKDRC"; then
        # Get the line number of the binding
        LINE_NUM=$(grep -n "^super + f" "$SXHKDRC" | cut -d: -f1)
        
        # Create a temporary file that replaces the binding
        {
            # Print file up to the binding line
            head -n $((LINE_NUM-1)) "$SXHKDRC"
            
            # Add the new binding
            echo "super + f"
            echo "	$FILE_MANAGER_CHOICE"
            
            # Print the rest of the file, skipping the old binding and command
            tail -n +$((LINE_NUM+2)) "$SXHKDRC"
        } > "${SXHKDRC}.tmp"
        
        # Replace the original file
        mv "${SXHKDRC}.tmp" "$SXHKDRC"
    else
        # Add new binding
        echo -e "\nsuper + f\n\t$FILE_MANAGER_CHOICE" >> "$SXHKDRC"
    fi
    echo "File manager shortcut set to Super+F"
fi

if [ -n "$TERMINAL_CHOICE" ]; then
    # Check if terminal binding already exists
    if grep -q "^super + Return" "$SXHKDRC"; then
        # Get the line number of the binding
        LINE_NUM=$(grep -n "^super + Return" "$SXHKDRC" | cut -d: -f1)
        
        # Create a temporary file that replaces the binding
        {
            # Print file up to the binding line
            head -n $((LINE_NUM-1)) "$SXHKDRC"
            
            # Add the new binding
            echo "super + Return"
            echo "	$TERMINAL_CHOICE"
            
            # Print the rest of the file, skipping the old binding and command
            tail -n +$((LINE_NUM+2)) "$SXHKDRC"
        } > "${SXHKDRC}.tmp"
        
        # Replace the original file
        mv "${SXHKDRC}.tmp" "$SXHKDRC"
    else
        # Add new binding
        echo -e "\nsuper + Return\n\t$TERMINAL_CHOICE" >> "$SXHKDRC"
    fi
    echo "Terminal shortcut set to Super+Return"
fi

# Simple success message
echo "Setup completed successfully"

# Basic completion message
dialog $DIALOG_OPTS --title "Done" \
       --msgbox "Setup complete.\n\nEnter to exit." \
       5 25

# Reload sxhkd if it's running
if pgrep -x "sxhkd" > /dev/null; then
    pkill -USR1 -x sxhkd
    echo "Shortcuts reloaded"
    echo "sxhkd configuration reloaded."
else
    echo "Note: sxhkd is not running. Changes will take effect when sxhkd starts."
fi

exit 0