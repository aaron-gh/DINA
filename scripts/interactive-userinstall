#!/usr/bin/env python3
#
# interactive-userinstall - Simple menu-based setup for DINA user preferences

import os
import sys
import shutil
import subprocess
import re
import signal

# Class for text colors
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

# Helper functions
def print_header(text):
    """Print a formatted header."""
    print(f"\n{Colors.HEADER}{Colors.BOLD}{text}{Colors.ENDC}")

def print_info(text):
    """Print an info message."""
    print(f"{Colors.BLUE}➜ {text}{Colors.ENDC}")

def print_success(text):
    """Print a success message."""
    print(f"{Colors.GREEN}✓ {text}{Colors.ENDC}")

def print_warning(text):
    """Print a warning message."""
    print(f"{Colors.YELLOW}⚠ {text}{Colors.ENDC}")

def print_error(text):
    """Print an error message."""
    print(f"{Colors.RED}✗ {text}{Colors.ENDC}", file=sys.stderr)

def ask_yes_no(question):
    """Ask a yes/no question and return the result."""
    while True:
        response = input(f"{question} (y/n): ").lower()
        if response in ['y', 'yes']:
            return True
        elif response in ['n', 'no']:
            return False
        print("Please answer y or n.")

def select_from_menu(items):
    """Display a menu and ask user to select an option."""
    if not items:
        return None
    
    # If only one item, select it automatically
    if len(items) == 1:
        print_info(f"Auto-selecting the only option: {items[0][0]}")
        return items[0]
    
    # Print menu options
    print_info("Available options:")
    for i, (name, path) in enumerate(items, 1):
        print(f"  {i}) {name}")
    
    # Get user selection
    while True:
        try:
            choice = input(f"Select an option (1-{len(items)}): ")
            idx = int(choice) - 1
            if 0 <= idx < len(items):
                return items[idx]
            print(f"Please enter a number between 1 and {len(items)}.")
        except ValueError:
            print("Please enter a valid number.")

def find_executables(names):
    """Find executable files in PATH."""
    found = []
    for name in names:
        try:
            path = shutil.which(name)
            if path:
                found.append((name, path))
        except Exception:
            pass
    return found

def update_sxhkdrc(key_binding, command_path):
    """Update sxhkdrc with the new key binding."""
    if not command_path:
        return False
    
    # Set up paths
    sxhkdrc = os.path.expanduser("~/.config/sxhkd/sxhkdrc")
    sxhkd_dir = os.path.dirname(sxhkdrc)
    
    # Create directory if needed
    if not os.path.exists(sxhkd_dir):
        os.makedirs(sxhkd_dir)
    
    # Find config file
    if not os.path.exists(sxhkdrc):
        # Try to find it in the DINA directory
        script_dir = os.path.dirname(os.path.abspath(__file__))
        dina_dir = os.path.dirname(script_dir)
        source_config = os.path.join(dina_dir, "sxhkd", "sxhkdrc")
        
        if os.path.exists(source_config):
            shutil.copy(source_config, sxhkdrc)
        else:
            print_error(f"Could not find sxhkdrc file.")
            return False
    
    # Backup config
    backup_file = f"{sxhkdrc}.bak"
    shutil.copy(sxhkdrc, backup_file)
    
    # Read the existing config
    with open(sxhkdrc, 'r') as f:
        lines = f.readlines()
    
    # Check if the key binding already exists
    found = False
    for i in range(len(lines)):
        if lines[i].strip() == key_binding:
            # Key binding found, update the next line
            if i + 1 < len(lines):
                lines[i + 1] = f"\t{command_path}\n"
                found = True
                break
    
    # If not found, append it
    if not found:
        lines.append(f"\n{key_binding}\n\t{command_path}\n")
    
    # Write the updated config
    with open(sxhkdrc, 'w') as f:
        f.writelines(lines)
    
    return True

def reload_sxhkd():
    """Reload sxhkd if it's running."""
    try:
        # Check if sxhkd is running
        subprocess.run(["pgrep", "-x", "sxhkd"], check=True, stdout=subprocess.PIPE)
        # Send the reload signal
        subprocess.run(["pkill", "-USR1", "-x", "sxhkd"])
        return True
    except subprocess.CalledProcessError:
        return False
    except Exception as e:
        print_warning(f"Error reloading sxhkd: {e}")
        return False

def main():
    # Show welcome message
    print_header("DINA Interactive Setup")
    print("======================")
    print("This will configure your preferred applications for DINA.")
    print()
    
    # Confirm setup
    if not ask_yes_no("Continue with setup?"):
        print("Setup cancelled")
        return
    
    # Discover applications
    print_info("Searching for installed applications...")
    
    # Define application types to look for
    app_types = {
        "browsers": [
            "firefox", "chromium", "chromium-browser", "google-chrome", 
            "brave", "vivaldi", "opera", "qutebrowser", "falkon", 
            "epiphany", "midori", "nyxt"
        ],
        "file_managers": [
            "nautilus", "thunar", "pcmanfm", "dolphin", "nemo", 
            "caja", "spacefm", "krusader", "ranger"
        ],
        "terminals": [
            "alacritty", "xterm", "urxvt", "kitty", "gnome-terminal", 
            "konsole", "terminator", "xfce4-terminal", "tilix", 
            "st", "foot", "wezterm"
        ]
    }
    
    # Find applications
    found_apps = {
        app_type: find_executables(apps)
        for app_type, apps in app_types.items()
    }
    
    # Select applications
    selections = {}
    
    # Browser selection
    print_header("Browser Selection")
    browsers = found_apps["browsers"]
    if browsers:
        selection = select_from_menu(browsers)
        if selection:
            name, path = selection
            selections["browser"] = (name, path)
            print_success(f"{name} selected as browser")
    else:
        print_warning("No browsers detected.")
        if ask_yes_no("Would you like to enter a custom browser path?"):
            custom_path = input("Enter path to browser: ")
            if os.path.isfile(custom_path) and os.access(custom_path, os.X_OK):
                name = os.path.basename(custom_path)
                selections["browser"] = (name, custom_path)
                print_success(f"Custom browser path set: {custom_path}")
            else:
                print_error("Invalid path, skipping browser selection")
    
    # File manager selection
    print_header("File Manager Selection")
    file_managers = found_apps["file_managers"]
    if file_managers:
        selection = select_from_menu(file_managers)
        if selection:
            name, path = selection
            selections["file_manager"] = (name, path)
            print_success(f"{name} selected as file manager")
    else:
        print_warning("No file managers detected.")
        if ask_yes_no("Would you like to enter a custom file manager path?"):
            custom_path = input("Enter path to file manager: ")
            if os.path.isfile(custom_path) and os.access(custom_path, os.X_OK):
                name = os.path.basename(custom_path)
                selections["file_manager"] = (name, custom_path)
                print_success(f"Custom file manager path set: {custom_path}")
            else:
                print_error("Invalid path, skipping file manager selection")
    
    # Terminal selection
    print_header("Terminal Selection")
    terminals = found_apps["terminals"]
    if terminals:
        selection = select_from_menu(terminals)
        if selection:
            name, path = selection
            selections["terminal"] = (name, path)
            print_success(f"{name} selected as terminal")
    else:
        print_warning("No terminals detected.")
        if ask_yes_no("Would you like to enter a custom terminal path?"):
            custom_path = input("Enter path to terminal: ")
            if os.path.isfile(custom_path) and os.access(custom_path, os.X_OK):
                name = os.path.basename(custom_path)
                selections["terminal"] = (name, custom_path)
                print_success(f"Custom terminal path set: {custom_path}")
            else:
                print_error("Invalid path, skipping terminal selection")
    
    # Show selections summary
    print_header("Selected Applications")
    print(f"Browser: {selections.get('browser', (None, None))[0] or 'None'}")
    print(f"File Manager: {selections.get('file_manager', (None, None))[0] or 'None'}")
    print(f"Terminal: {selections.get('terminal', (None, None))[0] or 'None'}")
    print()
    
    # Confirm selections
    if not ask_yes_no("Confirm these selections?"):
        print("Setup cancelled")
        return
    
    # Update configuration
    print_header("Updating Configuration")
    
    # Update key bindings
    key_bindings = {
        "browser": "super + w",
        "file_manager": "super + f",
        "terminal": "super + Return"
    }
    
    updated = False
    for app_type, binding in key_bindings.items():
        if app_type in selections:
            name, path = selections[app_type]
            if update_sxhkdrc(binding, path):
                print_success(f"{app_type.replace('_', ' ').title()} shortcut set to {binding}")
                updated = True
    
    # Reload sxhkd if needed
    if updated and reload_sxhkd():
        print_success("Shortcuts reloaded")
    
    print_header("Setup Completed Successfully!")

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nSetup cancelled by user")
        sys.exit(1)