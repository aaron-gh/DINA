#!/bin/bash
#
# interactive-userinstall - Setup user preferences for DINA
#
# This script detects installed applications and allows the user to
# select their preferred browsers, file managers, and terminals.
# It then updates sxhkdrc configuration with the selected preferences.
# Pure text-based interface for maximum accessibility.

set -e

# Function to handle errors
error_exit() {
    echo "Error: $1" >&2
    exit 1
}

# Text-based menu function
text_menu() {
    local title="$1"
    shift
    local options=("$@")
    local num_options=${#options[@]}
    
    echo
    echo -n "Enter selection (0-$((num_options-1))) or just press Enter to skip: "
    read choice
    
    # Return the choice
    echo "$choice"
}

# Text-based yes/no question
ask_yes_no() {
    local question="$1"
    
    while true; do
        echo
        echo "$question"
        echo -n "Enter y/n: "
        read answer
        case "$answer" in
            [Yy]* ) return 0 ;;
            [Nn]* ) return 1 ;;
            * ) echo "Please answer y or n.";;
        esac
    done
}

# Welcome message
echo "DINA Interactive Setup"
echo "======================"
echo "This will configure your preferred applications for DINA."
echo

if ! ask_yes_no "Continue with setup?"; then
    echo "Setup cancelled"
    exit 0
fi

# Detect installed browsers
BROWSERS=()
BROWSER_PATHS=()

check_browser() {
    if command -v "$1" >/dev/null 2>&1; then
        BROWSERS+=("$1")
        BROWSER_PATHS+=("$(command -v "$1")")
        return 0
    fi
    return 1
}

# Check for common browsers
check_browser "firefox" || true
check_browser "chromium" || true
check_browser "chromium-browser" || true
check_browser "google-chrome" || true
check_browser "brave" || true
check_browser "vivaldi" || true
check_browser "opera" || true
check_browser "qutebrowser" || true
check_browser "falkon" || true
check_browser "epiphany" || true
check_browser "midori" || true
check_browser "nyxt" || true

if [ ${#BROWSERS[@]} -eq 0 ]; then
    # Allow user to specify path manually
    echo
    echo "No browsers detected."
    echo -n "Enter path to browser (or press Enter to skip): "
    read BROWSER_PATH
    
    if [ -z "$BROWSER_PATH" ]; then
        echo "No browser selected"
        BROWSER_CHOICE=""
    elif [ ! -x "$BROWSER_PATH" ]; then
        error_exit "The specified browser path is not executable."
    else
        BROWSER_CHOICE="$BROWSER_PATH"
        echo "Custom browser path set"
    fi
else
    # Display browser selection menu
    echo "Found ${#BROWSERS[@]} browsers:"
    for i in "${!BROWSERS[@]}"; do
        echo "  $i. ${BROWSERS[$i]}"
    done
    
    choice=$(text_menu "Browser Selection" "${BROWSERS[@]}")
    
    if [ -z "$choice" ] || ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -ge ${#BROWSERS[@]} ]; then
        echo "No browser selected"
        BROWSER_CHOICE=""
    else
        BROWSER_CHOICE="${BROWSER_PATHS[$choice]}"
        echo "${BROWSERS[$choice]} selected"
    fi
fi

# Detect installed file managers
FILE_MANAGERS=()
FILE_MANAGER_PATHS=()

check_file_manager() {
    if command -v "$1" >/dev/null 2>&1; then
        FILE_MANAGERS+=("$1")
        FILE_MANAGER_PATHS+=("$(command -v "$1")")
        return 0
    fi
    return 1
}

# Check for common file managers
check_file_manager "nautilus" || true
check_file_manager "thunar" || true
check_file_manager "pcmanfm" || true
check_file_manager "dolphin" || true
check_file_manager "nemo" || true
check_file_manager "caja" || true
check_file_manager "spacefm" || true
check_file_manager "krusader" || true
check_file_manager "ranger" || true

if [ ${#FILE_MANAGERS[@]} -eq 0 ]; then
    # Allow user to specify path manually
    echo
    echo "No file managers detected."
    echo -n "Enter path to file manager (or press Enter to skip): "
    read FILE_MANAGER_PATH
    
    if [ -z "$FILE_MANAGER_PATH" ]; then
        echo "No file manager selected"
        FILE_MANAGER_CHOICE=""
    elif [ ! -x "$FILE_MANAGER_PATH" ]; then
        error_exit "The specified file manager path is not executable."
    else
        FILE_MANAGER_CHOICE="$FILE_MANAGER_PATH"
        echo "Custom file manager path set"
    fi
else
    # Display file manager selection menu
    echo "Found ${#FILE_MANAGERS[@]} file managers:"
    for i in "${!FILE_MANAGERS[@]}"; do
        echo "  $i. ${FILE_MANAGERS[$i]}"
    done
    
    choice=$(text_menu "File Manager Selection" "${FILE_MANAGERS[@]}")
    
    if [ -z "$choice" ] || ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -ge ${#FILE_MANAGERS[@]} ]; then
        echo "No file manager selected"
        FILE_MANAGER_CHOICE=""
    else
        FILE_MANAGER_CHOICE="${FILE_MANAGER_PATHS[$choice]}"
        echo "${FILE_MANAGERS[$choice]} selected"
    fi
fi

# Detect installed terminals
TERMINALS=()
TERMINAL_PATHS=()

check_terminal() {
    if command -v "$1" >/dev/null 2>&1; then
        TERMINALS+=("$1")
        TERMINAL_PATHS+=("$(command -v "$1")")
        return 0
    fi
    return 1
}

# Check for common terminals
check_terminal "alacritty" || true
check_terminal "xterm" || true
check_terminal "urxvt" || true
check_terminal "kitty" || true
check_terminal "gnome-terminal" || true
check_terminal "konsole" || true
check_terminal "terminator" || true
check_terminal "xfce4-terminal" || true
check_terminal "tilix" || true
check_terminal "st" || true
check_terminal "foot" || true
check_terminal "wezterm" || true

if [ ${#TERMINALS[@]} -eq 0 ]; then
    # Allow user to specify path manually
    echo
    echo "No terminals detected."
    echo -n "Enter path to terminal (or press Enter to skip): "
    read TERMINAL_PATH
    
    if [ -z "$TERMINAL_PATH" ]; then
        echo "No terminal selected"
        TERMINAL_CHOICE=""
    elif [ ! -x "$TERMINAL_PATH" ]; then
        error_exit "The specified terminal path is not executable."
    else
        TERMINAL_CHOICE="$TERMINAL_PATH"
        echo "Custom terminal path set"
    fi
else
    # Display terminal selection menu
    echo "Found ${#TERMINALS[@]} terminals:"
    for i in "${!TERMINALS[@]}"; do
        echo "  $i. ${TERMINALS[$i]}"
    done
    
    choice=$(text_menu "Terminal Selection" "${TERMINALS[@]}")
    
    if [ -z "$choice" ] || ! [[ "$choice" =~ ^[0-9]+$ ]] || [ "$choice" -ge ${#TERMINALS[@]} ]; then
        echo "No terminal selected"
        TERMINAL_CHOICE=""
    else
        TERMINAL_CHOICE="${TERMINAL_PATHS[$choice]}"
        echo "${TERMINALS[$choice]} selected"
    fi
fi

# Confirmation dialog with minimal text
BROWSER_NAME=$(basename "${BROWSER_CHOICE:-None}" 2>/dev/null || echo "None")
FILE_MANAGER_NAME=$(basename "${FILE_MANAGER_CHOICE:-None}" 2>/dev/null || echo "None")
TERMINAL_NAME=$(basename "${TERMINAL_CHOICE:-None}" 2>/dev/null || echo "None")

echo
echo "Your selections:"
echo "Browser: $BROWSER_NAME"
echo "File Manager: $FILE_MANAGER_NAME"
echo "Terminal: $TERMINAL_NAME"
echo

if ! ask_yes_no "Confirm these selections?"; then
    echo "Setup cancelled"
    exit 0
fi

echo "Updating configuration..."

# Path to sxhkdrc
SXHKDRC="$HOME/.config/sxhkd/sxhkdrc"
# Also check in DINA directory
if [ ! -f "$SXHKDRC" ]; then
    # Get the script's directory
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    # Go up one directory (assuming script is in scripts/)
    DINA_DIR="$(dirname "$SCRIPT_DIR")"
    SXHKDRC="$DINA_DIR/sxhkd/sxhkdrc"
fi

# Create ~/.config/sxhkd directory if it doesn't exist
if [ ! -d "$HOME/.config/sxhkd" ]; then
    mkdir -p "$HOME/.config/sxhkd"
fi

# If sxhkdrc doesn't exist in user's config, copy it from DINA
if [ ! -f "$HOME/.config/sxhkd/sxhkdrc" ]; then
    # Get the script's directory if not already set
    if [ -z "$SCRIPT_DIR" ]; then
        SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        DINA_DIR="$(dirname "$SCRIPT_DIR")"
    fi
    
    if [ -f "$DINA_DIR/sxhkd/sxhkdrc" ]; then
        cp "$DINA_DIR/sxhkd/sxhkdrc" "$HOME/.config/sxhkd/sxhkdrc"
        SXHKDRC="$HOME/.config/sxhkd/sxhkdrc"
    else
        error_exit "Could not find sxhkdrc file."
    fi
fi

# Make a backup of the original file
cp "$SXHKDRC" "${SXHKDRC}.bak"

# Update sxhkdrc with the selected applications
if [ -n "$BROWSER_CHOICE" ]; then
    # Check if browser binding already exists
    if grep -q "^super + w" "$SXHKDRC"; then
        # Get the line number of the binding
        LINE_NUM=$(grep -n "^super + w" "$SXHKDRC" | cut -d: -f1)
        
        # Create a temporary file that replaces the binding
        {
            # Print file up to the binding line
            head -n $((LINE_NUM-1)) "$SXHKDRC"
            
            # Add the new binding
            echo "super + w"
            echo "	$BROWSER_CHOICE"
            
            # Print the rest of the file, skipping the old binding and command
            tail -n +$((LINE_NUM+2)) "$SXHKDRC"
        } > "${SXHKDRC}.tmp"
        
        # Replace the original file
        mv "${SXHKDRC}.tmp" "$SXHKDRC"
    else
        # Add new binding
        echo -e "\nsuper + w\n\t$BROWSER_CHOICE" >> "$SXHKDRC"
    fi
    echo "Browser shortcut set to Super+W"
fi

if [ -n "$FILE_MANAGER_CHOICE" ]; then
    # Check if file manager binding already exists
    if grep -q "^super + f" "$SXHKDRC"; then
        # Get the line number of the binding
        LINE_NUM=$(grep -n "^super + f" "$SXHKDRC" | cut -d: -f1)
        
        # Create a temporary file that replaces the binding
        {
            # Print file up to the binding line
            head -n $((LINE_NUM-1)) "$SXHKDRC"
            
            # Add the new binding
            echo "super + f"
            echo "	$FILE_MANAGER_CHOICE"
            
            # Print the rest of the file, skipping the old binding and command
            tail -n +$((LINE_NUM+2)) "$SXHKDRC"
        } > "${SXHKDRC}.tmp"
        
        # Replace the original file
        mv "${SXHKDRC}.tmp" "$SXHKDRC"
    else
        # Add new binding
        echo -e "\nsuper + f\n\t$FILE_MANAGER_CHOICE" >> "$SXHKDRC"
    fi
    echo "File manager shortcut set to Super+F"
fi

if [ -n "$TERMINAL_CHOICE" ]; then
    # Check if terminal binding already exists
    if grep -q "^super + Return" "$SXHKDRC"; then
        # Get the line number of the binding
        LINE_NUM=$(grep -n "^super + Return" "$SXHKDRC" | cut -d: -f1)
        
        # Create a temporary file that replaces the binding
        {
            # Print file up to the binding line
            head -n $((LINE_NUM-1)) "$SXHKDRC"
            
            # Add the new binding
            echo "super + Return"
            echo "	$TERMINAL_CHOICE"
            
            # Print the rest of the file, skipping the old binding and command
            tail -n +$((LINE_NUM+2)) "$SXHKDRC"
        } > "${SXHKDRC}.tmp"
        
        # Replace the original file
        mv "${SXHKDRC}.tmp" "$SXHKDRC"
    else
        # Add new binding
        echo -e "\nsuper + Return\n\t$TERMINAL_CHOICE" >> "$SXHKDRC"
    fi
    echo "Terminal shortcut set to Super+Return"
fi

# Success message
echo
echo "Setup completed successfully"

# Reload sxhkd if it's running
if pgrep -x "sxhkd" > /dev/null; then
    pkill -USR1 -x sxhkd
    echo "Shortcuts reloaded"
fi

exit 0