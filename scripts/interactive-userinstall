#!/usr/bin/env python3
#
# interactive-userinstall - Simple menu-based setup for DINA user preferences

import os
import sys
import shutil
import subprocess
import re
import signal

# Class for text colors
class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

# Helper functions
def print_header(text):
    """Print a formatted header."""
    print(f"\n{Colors.HEADER}{Colors.BOLD}{text}{Colors.ENDC}")

def print_info(text):
    """Print an info message."""
    print(f"{Colors.BLUE}➜ {text}{Colors.ENDC}")

def print_success(text):
    """Print a success message."""
    print(f"{Colors.GREEN}✓ {text}{Colors.ENDC}")

def print_warning(text):
    """Print a warning message."""
    print(f"{Colors.YELLOW}⚠ {text}{Colors.ENDC}")

def print_error(text):
    """Print an error message."""
    print(f"{Colors.RED}✗ {text}{Colors.ENDC}", file=sys.stderr)

def ask_yes_no(question):
    """Ask a yes/no question and return the result."""
    while True:
        response = input(f"{question} (y/n): ").lower()
        if response in ['y', 'yes']:
            return True
        elif response in ['n', 'no']:
            return False
        print("Please answer y or n.")

def select_from_menu(items):
    """Display a menu and ask user to select an option."""
    if not items:
        return None
    
    # If only one item, select it automatically
    if len(items) == 1:
        print_info(f"Auto-selecting the only option: {items[0][0]}")
        return items[0]
    
    # Print menu options
    print_info("Available options:")
    for i, (name, path) in enumerate(items, 1):
        print(f"  {i}) {name}")
    
    # Get user selection
    while True:
        try:
            choice = input(f"Select an option (1-{len(items)}): ")
            idx = int(choice) - 1
            if 0 <= idx < len(items):
                return items[idx]
            print(f"Please enter a number between 1 and {len(items)}.")
        except ValueError:
            print("Please enter a valid number.")

def find_executables(names):
    """Find executable files in PATH."""
    found = []
    for name in names:
        try:
            path = shutil.which(name)
            if path:
                found.append((name, path))
        except Exception:
            pass
    return found

def write_dina_config(selections):
    """Write the DINA configuration file with keybindings and autostart settings.
    
    Args:
        selections: Dictionary of application selections (browser, file_manager, terminal)
    
    Returns:
        bool: True if config was written successfully, False otherwise
    """
    try:
        # Create the DINA config directory if it doesn't exist
        config_dir = os.path.expanduser("~/.config/dina")
        config_file = os.path.join(config_dir, "config")
        
        if not os.path.exists(config_dir):
            os.makedirs(config_dir)
            print_info(f"Created directory {config_dir}")
        
        # Check if config file already exists and create backup if needed
        if os.path.exists(config_file):
            backup_file = f"{config_file}.backup"
            shutil.copy2(config_file, backup_file)
            print_info(f"Created backup of existing config at {backup_file}")
        
        # Key binding mappings
        key_bindings = {
            "browser": {"key": "modifier+w", "desc": "web browser"},
            "file_manager": {"key": "modifier+f", "desc": "file manager"},
            "terminal": {"key": "modifier+Return", "desc": "terminal"}
        }
        
        # Write the config file
        with open(config_file, "w") as f:
            # Write header
            f.write("# DINA Window Manager Configuration\n")
            f.write("# Generated by interactive-userinstall script\n\n")
            
            # Write appearance section
            f.write("[appearance]\n")
            f.write("border_width = 1\n")
            f.write("snap_distance = 32\n")
            f.write("show_bar = false\n")
            f.write("font = \"monospace:size=10\"\n\n")
            
            # Write layout section
            f.write("[layout]\n")
            f.write("default_layout = \"monocle\"\n")
            f.write("resize_hints = false\n")
            f.write("lock_fullscreen = true\n\n")
            
            # Write workspaces section
            f.write("[workspaces]\n")
            f.write("tags = [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"]\n\n")
            
            # Write keybindings section
            f.write("[keybindings]\n")
            f.write("modifier = \"super\"\n\n")
            
            # Write default keybindings
            f.write("# Default keybindings\n")
            f.write("\"modifier+j\" = \"focus_previous\"\n")
            f.write("\"modifier+l\" = \"focus_next\"\n")
            f.write("\"modifier+k\" = \"close_window\"\n")
            f.write("\"modifier+BackSpace\" = \"exec:~/.local/bin/session-menu\"\n")
            f.write("\"modifier+a\" = \"exec:~/.local/bin/app-launcher\"\n")
            f.write("\"modifier+b\" = \"exec:~/.local/bin/toggle-blackout\"\n")
            f.write("\"modifier+Shift+q\" = \"quit\"\n\n")
            
            # Write workspace keybindings
            f.write("# Workspace switching\n")
            for i in range(1, 10):
                f.write(f"\"modifier+{i}\" = \"view_tag_{i}\"\n")
            f.write("\n")
            
            # Write window to workspace keybindings
            f.write("# Move windows to workspaces\n")
            for i in range(1, 10):
                f.write(f"\"modifier+Shift+{i}\" = \"move_to_tag_{i}\"\n")
            f.write("\n")
            
            # Write selected application keybindings
            f.write("# User selected applications\n")
            for app_type, binding in key_bindings.items():
                if app_type in selections:
                    name, path = selections[app_type]
                    f.write(f"# {binding['desc']}: {name}\n")
                    f.write(f"\"{binding['key']}\" = \"exec:{path}\"\n")
            f.write("\n")
            
            # Write autostart section
            f.write("[autostart]\n")
            f.write("# Programs to start when DINA launches\n")
            # Note: Orca is now started directly by DINA, no need for autostart script
            f.write("# Uncomment lines below to enable additional autostart programs\n")
            f.write("# compositor = \"picom --daemon\"\n")
            f.write("# keyboard = \"setxkbmap -option ctrl:nocaps\"\n\n")
            
            # Write accessibility section
            f.write("[accessibility]\n")
            f.write("# Sound/speech preferences\n")
            f.write("enable_sounds = true\n")
            f.write("sound_directory = \"~/.local/share/dina/sounds/\"\n")
            f.write("enable_screen_reader = true\n")
            f.write("announce_window_changes = true\n")
            f.write("announce_workspace_changes = true\n\n")
            
            # Write rules section
            f.write("[rules]\n")
            f.write("# Window placement rules\n")
            # Add browser rule if selected
            if "browser" in selections:
                name, _ = selections["browser"]
                f.write(f"\"{name}:*:*\" = {{ tags = \"2\", floating = false, monitor = 0 }}\n")
            
            # Add terminal rule if selected
            if "terminal" in selections:
                name, _ = selections["terminal"]
                f.write(f"\"{name}:*:*\" = {{ tags = \"1\", floating = false, monitor = 0 }}\n")
            
        print_success(f"Wrote DINA configuration to {config_file}")
        return True
    
    except Exception as e:
        print_error(f"Failed to write DINA config: {e}")
        return False

def install_scripts():
    """Install all scripts to the user's ~/.local/bin directory"""
    try:
        # Get the script directory and source script paths
        script_dir = os.path.dirname(os.path.abspath(__file__))
        bin_dir = os.path.expanduser("~/.local/bin")
        
        # Create bin directory if it doesn't exist
        if not os.path.exists(bin_dir):
            os.makedirs(bin_dir)
            print_info(f"Created directory {bin_dir}")
        
        # Get the list of scripts from the script directory
        scripts = [f for f in os.listdir(script_dir) if os.path.isfile(os.path.join(script_dir, f)) 
                  and not f.startswith('__') and not f.endswith('.pyc')]
        
        # Copy each script and make it executable
        for script in scripts:
            source = os.path.join(script_dir, script)
            dest = os.path.join(bin_dir, script)
            shutil.copy2(source, dest)
            os.chmod(dest, 0o755)  # rwxr-xr-x
            print_success(f"Installed {script} to {bin_dir}")
        
        return True
    except Exception as e:
        print_error(f"Failed to install scripts: {e}")
        return False

def main():
    # Show welcome message
    print_header("DINA Interactive Setup")
    print("======================")
    print("This will configure your preferred applications for DINA.")
    print()
    
    # Confirm setup
    if not ask_yes_no("Continue with setup?"):
        print("Setup cancelled")
        return
        
    # Install scripts
    print_header("Installing DINA Scripts")
    if install_scripts():
        print_success("All scripts installed to ~/.local/bin")
    else:
        print_warning("Some scripts may not have been installed correctly")
    
    # Discover applications
    print_info("Searching for installed applications...")
    
    # Define application types to look for
    app_types = {
        "browsers": [
            "firefox", "chromium", "chromium-browser", "google-chrome", 
            "brave", "vivaldi", "opera", "qutebrowser", "falkon", 
            "epiphany", "midori", "nyxt"
        ],
        "file_managers": [
            "nautilus", "thunar", "pcmanfm", "dolphin", "nemo", 
            "caja", "spacefm", "krusader", "ranger"
        ],
        "terminals": [
            "alacritty", "xterm", "urxvt", "kitty", "gnome-terminal", 
            "konsole", "terminator", "xfce4-terminal", "tilix", 
            "st", "foot", "wezterm"
        ]
    }
    
    # Find applications
    found_apps = {
        app_type: find_executables(apps)
        for app_type, apps in app_types.items()
    }
    
    # Select applications
    selections = {}
    
    # Browser selection
    print_header("Browser Selection")
    browsers = found_apps["browsers"]
    if browsers:
        selection = select_from_menu(browsers)
        if selection:
            name, path = selection
            selections["browser"] = (name, path)
            print_success(f"{name} selected as browser")
    else:
        print_warning("No browsers detected.")
        if ask_yes_no("Would you like to enter a custom browser path?"):
            custom_path = input("Enter path to browser: ")
            if os.path.isfile(custom_path) and os.access(custom_path, os.X_OK):
                name = os.path.basename(custom_path)
                selections["browser"] = (name, custom_path)
                print_success(f"Custom browser path set: {custom_path}")
            else:
                print_error("Invalid path, skipping browser selection")
    
    # File manager selection
    print_header("File Manager Selection")
    file_managers = found_apps["file_managers"]
    if file_managers:
        selection = select_from_menu(file_managers)
        if selection:
            name, path = selection
            selections["file_manager"] = (name, path)
            print_success(f"{name} selected as file manager")
    else:
        print_warning("No file managers detected.")
        if ask_yes_no("Would you like to enter a custom file manager path?"):
            custom_path = input("Enter path to file manager: ")
            if os.path.isfile(custom_path) and os.access(custom_path, os.X_OK):
                name = os.path.basename(custom_path)
                selections["file_manager"] = (name, custom_path)
                print_success(f"Custom file manager path set: {custom_path}")
            else:
                print_error("Invalid path, skipping file manager selection")
    
    # Terminal selection
    print_header("Terminal Selection")
    terminals = found_apps["terminals"]
    if terminals:
        selection = select_from_menu(terminals)
        if selection:
            name, path = selection
            selections["terminal"] = (name, path)
            print_success(f"{name} selected as terminal")
    else:
        print_warning("No terminals detected.")
        if ask_yes_no("Would you like to enter a custom terminal path?"):
            custom_path = input("Enter path to terminal: ")
            if os.path.isfile(custom_path) and os.access(custom_path, os.X_OK):
                name = os.path.basename(custom_path)
                selections["terminal"] = (name, custom_path)
                print_success(f"Custom terminal path set: {custom_path}")
            else:
                print_error("Invalid path, skipping terminal selection")
    
    # Show selections summary
    print_header("Selected Applications")
    print(f"Browser: {selections.get('browser', (None, None))[0] or 'None'}")
    print(f"File Manager: {selections.get('file_manager', (None, None))[0] or 'None'}")
    print(f"Terminal: {selections.get('terminal', (None, None))[0] or 'None'}")
    print()
    
    # Confirm selections
    if not ask_yes_no("Confirm these selections?"):
        print("Setup cancelled")
        return
    
    # Update configuration
    print_header("Updating Configuration")
    
    print_info("Writing new DINA configuration file...")
    
    # Write the DINA config file with selected applications
    if write_dina_config(selections):
        print_success("DINA configuration updated successfully")
        print_info("Your application preferences will be applied on next startup")
    else:
        print_warning("Failed to update DINA configuration")
    
    print_header("Setup Completed Successfully!")
    print_info("The next time you start DINA, your preferences will be applied.")

if __name__ == "__main__":
    try:
        # Check if we're just testing the script installation
        if len(sys.argv) > 1 and sys.argv[1] == "--test-script-install":
            print_header("Testing Script Installation")
            if install_scripts():
                print_success("All scripts installed to ~/.local/bin")
                sys.exit(0)
            else:
                print_error("Script installation failed")
                sys.exit(1)
        
        # Run the normal interactive setup
        main()
    except KeyboardInterrupt:
        print("\nSetup cancelled by user")
        sys.exit(1)