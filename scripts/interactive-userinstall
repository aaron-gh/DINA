#!/bin/bash
#
# interactive-userinstall - Setup user preferences for DINA
#
# This script detects installed applications and allows the user to
# select their preferred browsers, file managers, and terminals.
# It then updates sxhkdrc configuration with the selected preferences.
# Fully accessible with keyboard navigation using dialog.

set -e

# Enhanced accessibility options for dialog
DIALOG_OPTS="--ascii-lines --tab-correct --visit-items"

# Announce messages with speech-dispatcher for better screen reader support
announce() {
    if command -v spd-say >/dev/null 2>&1; then
        # Use synchronous speech announcement for critical messages
        if [ "$2" = "sync" ]; then
            spd-say -w "$1"
        else
            spd-say "$1" &
        fi
        # Add a small pause to allow speech to complete
        sleep 1
    fi
}

# Function to determine if Orca is running
is_orca_running() {
    pgrep -x "orca" >/dev/null
}

# Check if Orca is running and provide audio feedback
if is_orca_running; then
    announce "DINA interactive setup is starting with Orca screen reader support enabled." "sync"
else
    echo "Orca screen reader is not running. Setup will continue but may not be fully accessible."
    # Try to start Orca if it's installed
    if command -v orca >/dev/null 2>&1; then
        echo "Attempting to start Orca..."
        orca &
        sleep 3
        if is_orca_running; then
            announce "Orca screen reader has been started for accessibility." "sync"
        fi
    fi
fi

# Function to handle errors
error_exit() {
    message="Error: $1"
    echo "$message" >&2
    
    # Announce the error for screen readers
    if command -v spd-say >/dev/null 2>&1; then
        spd-say "Error: $1"
    fi
    
    # Show a dialog box with the error
    if command -v dialog >/dev/null 2>&1; then
        dialog $DIALOG_OPTS --title "Error" --backtitle "Press Enter to exit" \
               --msgbox "Error: $1\n\nPress Enter to exit." 10 70
    fi
    
    exit 1
}

# Check if dialog is installed
if ! command -v dialog >/dev/null 2>&1; then
    error_exit "dialog is required but not installed. Please install it first."
fi

# Display welcome message
announce "DINA Setup. Welcome to the interactive setup."
dialog $DIALOG_OPTS --title "DINA Setup" \
       --backtitle "Use arrow keys to navigate, Enter to select, Escape to cancel" \
       --msgbox "Welcome to the DINA interactive setup!\n\nThis wizard will help you configure your preferred applications.\n\nPress Enter to continue.\nPress Escape to cancel." \
       12 70 || {
    echo "Setup cancelled"
    announce "Setup cancelled"
    exit 0
}

# Detect installed browsers
BROWSERS=()
BROWSER_PATHS=()

check_browser() {
    if command -v "$1" >/dev/null 2>&1; then
        BROWSERS+=("$1")
        BROWSER_PATHS+=("$(command -v "$1")")
        return 0
    fi
    return 1
}

# Check for common browsers
check_browser "firefox" || true
check_browser "chromium" || true
check_browser "chromium-browser" || true
check_browser "google-chrome" || true
check_browser "brave" || true
check_browser "vivaldi" || true
check_browser "opera" || true
check_browser "qutebrowser" || true
check_browser "falkon" || true
check_browser "epiphany" || true
check_browser "midori" || true
check_browser "nyxt" || true

if [ ${#BROWSERS[@]} -eq 0 ]; then
    # Allow user to specify path manually
    announce "No browsers detected. Please enter the path to your browser."
    BROWSER_PATH=$(dialog $DIALOG_OPTS --title "Browser Selection" \
                         --backtitle "Use Tab to navigate, Enter to confirm, Escape to cancel" \
                         --inputbox "No browsers detected. Please enter the path to your browser:" \
                         10 70 \
                         3>&1 1>&2 2>&3)
    
    if [ $? -ne 0 ] || [ -z "$BROWSER_PATH" ]; then
        echo "No browser selected"
        BROWSER_CHOICE=""
    elif [ ! -x "$BROWSER_PATH" ]; then
        error_exit "The specified browser path is not executable."
    else
        BROWSER_CHOICE="$BROWSER_PATH"
        echo "Custom browser path set"
    fi
else
    # Create options for dialog
    OPTIONS=()
    for i in "${!BROWSERS[@]}"; do
        OPTIONS+=("$i" "${BROWSERS[$i]}")
    done
    
    # Display browser selection dialog
    announce "Browser selection. Select from $(${#BROWSERS[@]}) options. Use Up and Down arrow keys to navigate, Enter to select." "sync"
    # Add a pause before showing the dialog for better screen reader experience
    sleep 1
    
    # Modify menu to include number prefixes for improved screen reader feedback
    NUMBERED_OPTIONS=()
    for i in "${!OPTIONS[@]}"; do
        # Skip even indices to preserve the menu structure
        if [ $((i % 2)) -eq 0 ]; then
            option_number=$(($i/2+1))
            option_name="${OPTIONS[$i+1]}"
            # Format: "Number. Name" - this improves screen reader reading
            NUMBERED_OPTIONS+=("${OPTIONS[$i]}" "Option $option_number: $option_name")
        fi
    done
    
    # Add help text for improved accessibility
    dialog $DIALOG_OPTS --title "Navigation Help" \
           --msgbox "You will now select a web browser.\n\n- ARROW DOWN: Move to next option\n- ARROW UP: Move to previous option\n- ENTER: Select highlighted option\n- ESC: Cancel\n\nPress ENTER to continue." \
           15 70
    
    BROWSER_INDEX=$(dialog $DIALOG_OPTS --title "Browser Selection" \
                          --backtitle "Use Up/Down arrows to navigate, Enter to select, Escape to cancel" \
                          --menu "Select your preferred web browser (use Up/Down, then Enter):" \
                          15 70 10 \
                          "${NUMBERED_OPTIONS[@]}" \
                          3>&1 1>&2 2>&3)
                          
    # Check the dialog return code
    BROWSER_RESULT=$?
    
    # Announce the selection
    if [ $BROWSER_RESULT -eq 0 ] && [ -n "$BROWSER_INDEX" ]; then
        BROWSER_CHOICE="${BROWSER_PATHS[$BROWSER_INDEX]}"
        echo "${BROWSERS[$BROWSER_INDEX]} selected"
        announce "You selected ${BROWSERS[$BROWSER_INDEX]}" "sync"
    else
        echo "No browser selected"
        BROWSER_CHOICE=""
        announce "No browser selected" "sync"
    fi
fi

# Detect installed file managers
FILE_MANAGERS=()
FILE_MANAGER_PATHS=()

check_file_manager() {
    if command -v "$1" >/dev/null 2>&1; then
        FILE_MANAGERS+=("$1")
        FILE_MANAGER_PATHS+=("$(command -v "$1")")
        return 0
    fi
    return 1
}

# Check for common file managers
check_file_manager "nautilus" || true
check_file_manager "thunar" || true
check_file_manager "pcmanfm" || true
check_file_manager "dolphin" || true
check_file_manager "nemo" || true
check_file_manager "caja" || true
check_file_manager "spacefm" || true
check_file_manager "krusader" || true
check_file_manager "ranger" || true

if [ ${#FILE_MANAGERS[@]} -eq 0 ]; then
    # Allow user to specify path manually
    announce "No file managers detected. Please enter the path to your file manager."
    FILE_MANAGER_PATH=$(dialog $DIALOG_OPTS --title "File Manager Selection" \
                              --backtitle "Use Tab to navigate, Enter to confirm, Escape to cancel" \
                              --inputbox "No file managers detected. Please enter the path to your file manager:" \
                              10 70 \
                              3>&1 1>&2 2>&3)
    
    if [ $? -ne 0 ] || [ -z "$FILE_MANAGER_PATH" ]; then
        echo "No file manager selected"
        FILE_MANAGER_CHOICE=""
    elif [ ! -x "$FILE_MANAGER_PATH" ]; then
        error_exit "The specified file manager path is not executable."
    else
        FILE_MANAGER_CHOICE="$FILE_MANAGER_PATH"
        echo "Custom file manager path set"
    fi
else
    # Create options for dialog
    OPTIONS=()
    for i in "${!FILE_MANAGERS[@]}"; do
        OPTIONS+=("$i" "${FILE_MANAGERS[$i]}")
    done
    
    # Display file manager selection dialog
    announce "File manager selection. Select from $(${#FILE_MANAGERS[@]}) options. Use Up and Down arrow keys to navigate, Enter to select." "sync"
    # Add a pause before showing the dialog for better screen reader experience
    sleep 1
    
    # Modify menu to include number prefixes for improved screen reader feedback
    NUMBERED_OPTIONS=()
    for i in "${!OPTIONS[@]}"; do
        # Skip even indices to preserve the menu structure
        if [ $((i % 2)) -eq 0 ]; then
            option_number=$(($i/2+1))
            option_name="${OPTIONS[$i+1]}"
            # Format: "Number. Name" - this improves screen reader reading
            NUMBERED_OPTIONS+=("${OPTIONS[$i]}" "Option $option_number: $option_name")
        fi
    done
    
    # Add help text for improved accessibility
    dialog $DIALOG_OPTS --title "Navigation Help" \
           --msgbox "You will now select a file manager.\n\n- ARROW DOWN: Move to next option\n- ARROW UP: Move to previous option\n- ENTER: Select highlighted option\n- ESC: Cancel\n\nPress ENTER to continue." \
           15 70
    
    FILE_MANAGER_INDEX=$(dialog $DIALOG_OPTS --title "File Manager Selection" \
                               --backtitle "Use Up/Down arrows to navigate, Enter to select, Escape to cancel" \
                               --menu "Select your preferred file manager (use Up/Down, then Enter):" \
                               15 70 10 \
                               "${NUMBERED_OPTIONS[@]}" \
                               3>&1 1>&2 2>&3)
                               
    # Check the dialog return code
    FILE_MANAGER_RESULT=$?
    
    # Announce the selection
    if [ $FILE_MANAGER_RESULT -eq 0 ] && [ -n "$FILE_MANAGER_INDEX" ]; then
        FILE_MANAGER_CHOICE="${FILE_MANAGER_PATHS[$FILE_MANAGER_INDEX]}"
        echo "${FILE_MANAGERS[$FILE_MANAGER_INDEX]} selected"
        announce "You selected ${FILE_MANAGERS[$FILE_MANAGER_INDEX]}" "sync"
    else
        echo "No file manager selected"
        FILE_MANAGER_CHOICE=""
        announce "No file manager selected" "sync"
    fi
fi

# Detect installed terminals
TERMINALS=()
TERMINAL_PATHS=()

check_terminal() {
    if command -v "$1" >/dev/null 2>&1; then
        TERMINALS+=("$1")
        TERMINAL_PATHS+=("$(command -v "$1")")
        return 0
    fi
    return 1
}

# Check for common terminals
check_terminal "alacritty" || true
check_terminal "xterm" || true
check_terminal "urxvt" || true
check_terminal "kitty" || true
check_terminal "gnome-terminal" || true
check_terminal "konsole" || true
check_terminal "terminator" || true
check_terminal "xfce4-terminal" || true
check_terminal "tilix" || true
check_terminal "st" || true
check_terminal "foot" || true
check_terminal "wezterm" || true

if [ ${#TERMINALS[@]} -eq 0 ]; then
    # Allow user to specify path manually
    announce "No terminals detected. Please enter the path to your terminal."
    TERMINAL_PATH=$(dialog $DIALOG_OPTS --title "Terminal Selection" \
                         --backtitle "Use Tab to navigate, Enter to confirm, Escape to cancel" \
                         --inputbox "No terminals detected. Please enter the path to your terminal:" \
                         10 70 \
                         3>&1 1>&2 2>&3)
    
    if [ $? -ne 0 ] || [ -z "$TERMINAL_PATH" ]; then
        echo "No terminal selected"
        TERMINAL_CHOICE=""
    elif [ ! -x "$TERMINAL_PATH" ]; then
        error_exit "The specified terminal path is not executable."
    else
        TERMINAL_CHOICE="$TERMINAL_PATH"
        echo "Custom terminal path set"
    fi
else
    # Create options for dialog
    OPTIONS=()
    for i in "${!TERMINALS[@]}"; do
        OPTIONS+=("$i" "${TERMINALS[$i]}")
    done
    
    # Display terminal selection dialog
    announce "Terminal selection. Select from $(${#TERMINALS[@]}) options. Use Up and Down arrow keys to navigate, Enter to select." "sync"
    # Add a pause before showing the dialog for better screen reader experience
    sleep 1
    
    # Modify menu to include number prefixes for improved screen reader feedback
    NUMBERED_OPTIONS=()
    for i in "${!OPTIONS[@]}"; do
        # Skip even indices to preserve the menu structure
        if [ $((i % 2)) -eq 0 ]; then
            option_number=$(($i/2+1))
            option_name="${OPTIONS[$i+1]}"
            # Format: "Number. Name" - this improves screen reader reading
            NUMBERED_OPTIONS+=("${OPTIONS[$i]}" "Option $option_number: $option_name")
        fi
    done
    
    # Add help text for improved accessibility
    dialog $DIALOG_OPTS --title "Navigation Help" \
           --msgbox "You will now select a terminal.\n\n- ARROW DOWN: Move to next option\n- ARROW UP: Move to previous option\n- ENTER: Select highlighted option\n- ESC: Cancel\n\nPress ENTER to continue." \
           15 70
    
    TERMINAL_INDEX=$(dialog $DIALOG_OPTS --title "Terminal Selection" \
                           --backtitle "Use Up/Down arrows to navigate, Enter to select, Escape to cancel" \
                           --menu "Select your preferred terminal (use Up/Down, then Enter):" \
                           15 70 10 \
                           "${NUMBERED_OPTIONS[@]}" \
                           3>&1 1>&2 2>&3)
                           
    # Check the dialog return code
    TERMINAL_RESULT=$?
    
    # Announce the selection
    if [ $TERMINAL_RESULT -eq 0 ] && [ -n "$TERMINAL_INDEX" ]; then
        TERMINAL_CHOICE="${TERMINAL_PATHS[$TERMINAL_INDEX]}"
        echo "${TERMINALS[$TERMINAL_INDEX]} selected"
        announce "You selected ${TERMINALS[$TERMINAL_INDEX]}" "sync"
    else
        echo "No terminal selected"
        TERMINAL_CHOICE=""
        announce "No terminal selected" "sync"
    fi
fi

# Confirmation dialog
# Prepare a summary of selections
BROWSER_NAME=$(basename "${BROWSER_CHOICE:-None}" 2>/dev/null || echo "None")
FILE_MANAGER_NAME=$(basename "${FILE_MANAGER_CHOICE:-None}" 2>/dev/null || echo "None")
TERMINAL_NAME=$(basename "${TERMINAL_CHOICE:-None}" 2>/dev/null || echo "None")

# Announce confirmation clearly
announce "Please confirm your selections." "sync"
sleep 1
announce "Browser: $BROWSER_NAME" "sync"
sleep 1
announce "File Manager: $FILE_MANAGER_NAME" "sync"
sleep 1
announce "Terminal: $TERMINAL_NAME" "sync"
sleep 1
announce "Press Enter to confirm these choices, or Escape to cancel." "sync"

CONFIRM=$(dialog $DIALOG_OPTS --title "Confirm Selections" \
                --backtitle "Press Enter for Yes, Escape for No" \
                --yesno "Are these selections correct?\n\nBrowser: ${BROWSER_CHOICE:-None}\nFile Manager: ${FILE_MANAGER_CHOICE:-None}\nTerminal: ${TERMINAL_CHOICE:-None}\n\nPress Enter to confirm, Escape to cancel." \
                12 70 \
                3>&1 1>&2 2>&3)

if [ $? -ne 0 ]; then
    echo "Setup cancelled"
    echo "Setup cancelled by user." >&2
    announce "Setup cancelled by user."
    exit 0
fi

echo "Updating configuration..."

# Path to sxhkdrc
SXHKDRC="$HOME/.config/sxhkd/sxhkdrc"
# Also check in DINA directory
if [ ! -f "$SXHKDRC" ]; then
    # Get the script's directory
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    # Go up one directory (assuming script is in scripts/)
    DINA_DIR="$(dirname "$SCRIPT_DIR")"
    SXHKDRC="$DINA_DIR/sxhkd/sxhkdrc"
fi

# Create ~/.config/sxhkd directory if it doesn't exist
if [ ! -d "$HOME/.config/sxhkd" ]; then
    mkdir -p "$HOME/.config/sxhkd"
fi

# If sxhkdrc doesn't exist in user's config, copy it from DINA
if [ ! -f "$HOME/.config/sxhkd/sxhkdrc" ]; then
    # Get the script's directory if not already set
    if [ -z "$SCRIPT_DIR" ]; then
        SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
        DINA_DIR="$(dirname "$SCRIPT_DIR")"
    fi
    
    if [ -f "$DINA_DIR/sxhkd/sxhkdrc" ]; then
        cp "$DINA_DIR/sxhkd/sxhkdrc" "$HOME/.config/sxhkd/sxhkdrc"
        SXHKDRC="$HOME/.config/sxhkd/sxhkdrc"
    else
        error_exit "Could not find sxhkdrc file."
    fi
fi

# Make a backup of the original file
cp "$SXHKDRC" "${SXHKDRC}.bak"

# Update sxhkdrc with the selected applications
if [ -n "$BROWSER_CHOICE" ]; then
    # Check if browser binding already exists
    if grep -q "^super + w" "$SXHKDRC"; then
        # Get the line number of the binding
        LINE_NUM=$(grep -n "^super + w" "$SXHKDRC" | cut -d: -f1)
        
        # Create a temporary file that replaces the binding
        {
            # Print file up to the binding line
            head -n $((LINE_NUM-1)) "$SXHKDRC"
            
            # Add the new binding
            echo "super + w"
            echo "	$BROWSER_CHOICE"
            
            # Print the rest of the file, skipping the old binding and command
            tail -n +$((LINE_NUM+2)) "$SXHKDRC"
        } > "${SXHKDRC}.tmp"
        
        # Replace the original file
        mv "${SXHKDRC}.tmp" "$SXHKDRC"
    else
        # Add new binding
        echo -e "\nsuper + w\n\t$BROWSER_CHOICE" >> "$SXHKDRC"
    fi
    echo "Browser shortcut set to Super+W"
fi

if [ -n "$FILE_MANAGER_CHOICE" ]; then
    # Check if file manager binding already exists
    if grep -q "^super + f" "$SXHKDRC"; then
        # Get the line number of the binding
        LINE_NUM=$(grep -n "^super + f" "$SXHKDRC" | cut -d: -f1)
        
        # Create a temporary file that replaces the binding
        {
            # Print file up to the binding line
            head -n $((LINE_NUM-1)) "$SXHKDRC"
            
            # Add the new binding
            echo "super + f"
            echo "	$FILE_MANAGER_CHOICE"
            
            # Print the rest of the file, skipping the old binding and command
            tail -n +$((LINE_NUM+2)) "$SXHKDRC"
        } > "${SXHKDRC}.tmp"
        
        # Replace the original file
        mv "${SXHKDRC}.tmp" "$SXHKDRC"
    else
        # Add new binding
        echo -e "\nsuper + f\n\t$FILE_MANAGER_CHOICE" >> "$SXHKDRC"
    fi
    echo "File manager shortcut set to Super+F"
fi

if [ -n "$TERMINAL_CHOICE" ]; then
    # Check if terminal binding already exists
    if grep -q "^super + Return" "$SXHKDRC"; then
        # Get the line number of the binding
        LINE_NUM=$(grep -n "^super + Return" "$SXHKDRC" | cut -d: -f1)
        
        # Create a temporary file that replaces the binding
        {
            # Print file up to the binding line
            head -n $((LINE_NUM-1)) "$SXHKDRC"
            
            # Add the new binding
            echo "super + Return"
            echo "	$TERMINAL_CHOICE"
            
            # Print the rest of the file, skipping the old binding and command
            tail -n +$((LINE_NUM+2)) "$SXHKDRC"
        } > "${SXHKDRC}.tmp"
        
        # Replace the original file
        mv "${SXHKDRC}.tmp" "$SXHKDRC"
    else
        # Add new binding
        echo -e "\nsuper + Return\n\t$TERMINAL_CHOICE" >> "$SXHKDRC"
    fi
    echo "Terminal shortcut set to Super+Return"
fi

# Success message
echo "Setup completed successfully"

# Prepare a summary of selections for the final announcement
BROWSER_NAME=$(basename "${BROWSER_CHOICE:-None}" 2>/dev/null || echo "None")
FILE_MANAGER_NAME=$(basename "${FILE_MANAGER_CHOICE:-None}" 2>/dev/null || echo "None")
TERMINAL_NAME=$(basename "${TERMINAL_CHOICE:-None}" 2>/dev/null || echo "None")

# Announce completion clearly
announce "Setup completed successfully. Your preferences have been saved." "sync"
sleep 1
announce "Browser set to $BROWSER_NAME" "sync"
sleep 1
announce "File Manager set to $FILE_MANAGER_NAME" "sync"
sleep 1
announce "Terminal set to $TERMINAL_NAME" "sync"
sleep 1
announce "Press Enter to exit." "sync"

dialog $DIALOG_OPTS --title "Setup Complete" \
       --backtitle "Press Enter to exit" \
       --msgbox "DINA has been configured with your preferences.\n\nBrowser: ${BROWSER_NAME}\nFile Manager: ${FILE_MANAGER_NAME}\nTerminal: ${TERMINAL_NAME}\n\nPress Enter to exit." \
       12 70

# Reload sxhkd if it's running
if pgrep -x "sxhkd" > /dev/null; then
    pkill -USR1 -x sxhkd
    echo "Shortcuts reloaded"
    echo "sxhkd configuration reloaded."
else
    echo "Note: sxhkd is not running. Changes will take effect when sxhkd starts."
fi

exit 0