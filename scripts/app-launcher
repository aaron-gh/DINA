#!/usr/bin/env python3
#
# app-launcher - YAD-based application launcher for DINA
#
# Parses .desktop files and displays applications in an accessible menu

import os
import subprocess
import glob
import re
import shlex
import sys

# Add verbose mode flag
verbose = "-v" in sys.argv or "--verbose" in sys.argv

def debug(message):
    """Print debug message if verbose mode is enabled"""
    if verbose:
        print(f"DEBUG: {message}")

def find_desktop_files():
    """Find all desktop files in standard locations"""
    locations = [
        "/usr/share/applications/*.desktop",
        os.path.expanduser("~/.local/share/applications/*.desktop")
    ]
    
    desktop_files = []
    for location in locations:
        desktop_files.extend(glob.glob(location))
    
    debug(f"Searching for desktop files...")
    debug(f"Found {len(desktop_files)} desktop files")
    return desktop_files

def parse_desktop_file(desktop_file):
    """Extract name and command from desktop file"""
    name = None
    exec_cmd = None
    in_desktop_entry = False
    in_desktop_action = False
    
    try:
        with open(desktop_file, 'r', encoding='utf-8') as f:
            for line in f:
                # Track sections in the desktop file
                if line.strip() == "[Desktop Entry]":
                    in_desktop_entry = True
                    in_desktop_action = False
                    continue
                elif line.startswith("[Desktop Action"):
                    in_desktop_entry = False
                    in_desktop_action = True
                    continue
                elif line.startswith("["):
                    in_desktop_entry = False
                    in_desktop_action = False
                    continue
                
                # Only process lines from the Desktop Entry section
                if in_desktop_entry:
                    if line.startswith('Name='):
                        name = line.strip()[5:]
                    elif line.startswith('Exec='):
                        exec_cmd = line.strip()[5:]
                        # Special care for Firefox PWA entries: preserve the --protocol %u argument
                        if "firefoxpwa" in exec_cmd and "--protocol %u" in exec_cmd:
                            exec_cmd = exec_cmd.replace("--protocol %u", "--protocol")
                        else:
                            # Remove field codes like %f, %F, %u, etc.
                            exec_cmd = re.sub(r'\s*%[a-zA-Z]', '', exec_cmd)
                        # Make sure arguments are properly separated
                        exec_cmd = exec_cmd.strip()
    except (IOError, UnicodeDecodeError) as e:
        if verbose:
            debug(f"Error reading {desktop_file}: {str(e)}")
        return None, None
    
    return name, exec_cmd

def main():
    # Find and parse desktop files
    app_map = {}
    pwa_map = {}  # Separate map for web apps
    
    for desktop_file in find_desktop_files():
        name, exec_cmd = parse_desktop_file(desktop_file)
        if name and exec_cmd:
            debug(f"{desktop_file} -> Name: {name}, Exec: {exec_cmd}")
            # Check if it's a Firefox PWA
            if "firefoxpwa" in exec_cmd:
                debug(f"Found Firefox PWA: {name}")
                if name not in pwa_map:
                    pwa_map[name] = exec_cmd
            elif name not in app_map:  # Regular applications
                app_map[name] = exec_cmd
    
    # Debug PWA count
    debug(f"Found {len(pwa_map)} Firefox PWAs")
    for name, cmd in pwa_map.items():
        debug(f"Adding PWA to menu: {name} -> {cmd}")
    
    # Format entries for YAD
    entries = []
    
    # Add regular applications
    for name, exec_cmd in sorted(app_map.items(), key=lambda x: x[0].lower()):
        entries.append(f"{name}|{exec_cmd}")
        
    # Add Firefox PWAs with a separator if any exist
    if pwa_map:
        entries.append(f"--- Web Apps ---|")
        for name, exec_cmd in sorted(pwa_map.items(), key=lambda x: x[0].lower()):
            # Using a clean label without trailing format placeholders
            entries.append(f"{name} (Web App)|{exec_cmd}")
    
    if not entries:
        print("No applications found")
        return
    
    # Create YAD command
    yad_cmd = [
        "yad", "--list", 
        "--title=Applications", 
        "--width=600", "--height=400",
        "--center", 
        "--column=Application", "--column=Command",
        "--hide-column=2",
        "--search-column=1",
        "--separator=|",
        "--no-markup"
    ]
    
    # Pass entries to YAD and get selection
    try:
        proc = subprocess.Popen(yad_cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, text=True)
        selection, _ = proc.communicate(input="\n".join(entries))
        
        # If a selection was made, launch the application
        if selection.strip():
            parts = selection.strip().split('|')
            if len(parts) > 1:
                cmd = parts[1]
                if cmd:
                    print(f"Launching: {cmd}")
                    # Handle special case for Firefox PWAs which might need shell=True
                    if "firefoxpwa" in cmd:
                        print(f"Launching Firefox PWA: {cmd}")
                        # For Firefox PWAs, we need to handle quotes in the URL properly
                        # Using shell=True ensures proper handling of complex command
                        subprocess.Popen(
                            cmd,
                            shell=True,
                            stdout=subprocess.DEVNULL, 
                            stderr=subprocess.DEVNULL,
                            start_new_session=True
                        )
                    else:
                        # Use Popen to avoid blocking and detach from parent process
                        subprocess.Popen(
                            shlex.split(cmd), 
                            stdout=subprocess.DEVNULL, 
                            stderr=subprocess.DEVNULL,
                            start_new_session=True
                        )
    except Exception as e:
        print(f"Error launching application: {e}")

if __name__ == "__main__":
    main()